<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>apply concat and friends</title>
<style>
html {
  background: url('pasley.jpg');
  background-size: 200px;
  font-family: serif;
}
figcaption { font-family: sans-serif; }
main {
  max-width: 70ch;
  padding: 2ch;
  margin: auto;
  background: #fff;
}
p code {
  white-space: nowrap;
  background: #eef;
}
pre {
  border-left: 4px #ccf solid;
  padding-left: 2em;
  background: #eaeaff;
}
pre.prn {
  margin-top: -0.8em;
  border-left: 4px #cfc solid;
  background: #eaffea;
  font-weight: bold;
}
code {
  background: #eaeaff;
  padding: 0 0.5ex;
}
.twitter-tweet {
  /*
  padding: 0px 20px 11.6px 20px;
  border: 1px solid #e1e8ed;
  border-radius: 5px;
  max-width: 520px;
  */
}
.laziness-svg { width: 115px; height 56px; float: right;}
.byline { text-align: right; font-style: italic; }
.dialog td:first-child {
  text-align: right;
  padding-right: 1ex;
}
.examples td { padding: 0 1em; }
</style>

<!--
<link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet">
-->

</head>

<body>

<main>

<!--

<h1><code>apply concat</code> <em>and friends</em></h1>

<p>The other day at work, writing a function, I typed <code>mapcat
seq</code>...</p>

<table class="dialog">
<tr><td><b>Me: </b></td><td>Hey, are you familiar with this?</td></tr>
<tr><td><b>Pairing partner: </b></td><td>Nope</td></tr>
<tr><td><b>Me: </b></td><td>Ah, well <code>(mapcat seq xs)</code> is just like <code>(apply concat xs)</code></td></tr>
<tr><td><b>Pairing partner: </b></td><td>Oh, so why not just use <code>(apply concat xs)</code>?</td></tr>
<tr><td><b>Me: </b></td><td>...</td></tr>
</table>

<p>The truth is I had never thought of <code>mapcat seq</code> until Christophe
first mentioned it some years ago, but then I noticed it saves 2 characters
compared to <code>apply concat</code> and have used it ever since.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Just realized that (mapcat seq x) is a pleasant alternative to (apply concat x). <a href="https://twitter.com/hashtag/clojure?src=hash&amp;ref_src=twsrc%5Etfw">#clojure</a></p>&mdash; Christophe Grand (@cgrand) <a href="https://twitter.com/cgrand/status/243793887532052480?ref_src=twsrc%5Etfw">September 6, 2012</a></blockquote>

<figure style="float: right; width: 286px;">
<img alt="Cat on her back with a treasure map on her belly."
  src="mapcat-seq.svg" onerror="this.src='mapcat-seq.jpg'"
  style="width: 286px; height: 135px">
<figcaption>
<b><code>mapcat seq</code> – </b>A close cousin to <code>mapcat identity</code>,
and my favorite for the last several years.
</figcaption>
</figure>

<p>Two characters is of course a silly reason to choose one over the other, in
all but the most <a href="http://www.4clojure.com/">4clojure</a> of
circumstances. But they are very similar and there are other alternatives, so
which is best? I decided to carefully study this question by conducting a
rigorously controlled and scientific Twitter poll. Twenty-four hours later I had
my answer:</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Just because they do different things doesn&#39;t mean you can&#39;t have a favorite.</p>&mdash; Chouser (@chrishouser) <a href="https://twitter.com/chrishouser/status/1118913793512411136?ref_src=twsrc%5Etfw">April 18, 2019</a>
<img src="shot-20190517-090932.png" style="width: 175px; height: 172px"
  alt="Twitter poll results:
  (mapcat seq xs) 9%; (mapcat identity xs) 24%; (apply concat xs) 34%; (flatten xs) 33%">
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>I don't know what I was expecting, but I can live with more respondents liking <code>apply
concat</code> than the alternatives in the poll. Maybe I should conform for the
sake of community. But it barely beat out <code>flatten</code>, and that is
entirely unacceptable! I had no choice to but to immediately dawdle,
procrastinate, and finally four months later write a blog post about it.</p>

<h2>The infamous <code>flatten</code></h2>

<p>The other three options in the poll are indeed very similar. In fact their
differences are so subtle, I really doubt you will ever regret whichever one use
choose to use. I dare not, however, make this same prediction about
<code>flatten</code>, for I fear if you use it in innocence it will betray
you.</p>

<p>To explain why, let's first look at an example for which all four
expressions return the same value:</p>

<pre>
(flatten [[1 2 3] [4 5 6] [7 8 9]])
;=&gt; (1 2 3 4 5 6 7 8 9)
</pre>

<p>When you reach for any of these expressions, this is usually what you're
thinking of: take a sequence of things and stitch them together into a single
sequence. And <code>flatten</code> indeed does this, but it does a lot more.
Let's peek at its definition:</p>

<pre>
(defn flatten
  "Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat lazy sequence.
  (flatten nil) returns an empty sequence."
  {:added "1.2"
   :static true}
  [x]
  (filter (complement sequential?)
          (rest (tree-seq sequential? seq x))))
</pre>

<figure style="float: right; width: 211px;">
<img alt="Flattened cat. Looks surprised."
  src="flatten.svg" onerror="this.src='flatten.jpg'"
  style="width: 211px; height: 213px; 135px">
<figcaption>
  <b><code>flatten</code> – </b>Looks surprised. You will be too.
</figcaption>
</figure>

<p>First, please note the use of <code>tree-seq</code>, an amazingly powerful
little function for processing any kind of tree into a lazy sequence. It's use
(and the mention of "nested" in the docstring) suggest <code>flatten</code> is
treating its input as a tree, not just a sequence of "things". So whereas
<code>apply concat</code> and <code>mapcat seq</code> <i>assume</i> their input
is a sequence of seqables and stop there, <code>flatten</code> examines each
element and may choose to descend deeper into the input, examining as it goes.</p>

<p>Second, note that it uses <code>sequential?</code>, an infrequently used
predicate in my experience, to choose when to descend. Would it surprise you to
learn that persistent queues are <code>sequential?</code>, but strings, sets,
and arrays are not? How confident are you that future maintainers of your code
know this?</p>

<p>With this knowledge we can construct a couple examples where
<code>flatten</code> behaves differently from the alternatives in the poll.</p>

<table class="examples">
  <tr>
    <th><i>input</i></th>
    <th><code>flatten</code></th>
    <th><code>apply concat</code> and others</th>
  </tr>
  <tr>
    <td><code>[[1 2 3] 4 [5 6]]</code></td>
    <td><code>(1 2 3 4 5 6)</code></td>
    <td><i>error</i></td>
  </tr>
  <tr>
    <td><code>[[1 [2 3]] [4 5 6]]</code></td>
    <td><code>(1 2 3 4 5 6)</code></td>
    <td><code>(1 [2 3] 4 5 6)</code></td>
  </tr>
  <tr>
    <td><code>[[1 2 3] #{4 5 6}]</code></td>
    <td><code>(1 2 3 #{4 6 5})</code></td>
    <td><code>(1 2 3 4 6 5)</code></td>
  </tr>
</table>

<p>So beware, <code>flatten</code> is different and more complicated than the
alternatives. Only rarely do I have multiple levels of nested sequences that I
want to flatten, where </code>sequential?</code> correctly defines when I want
it to descend. I'm not alone in warning about its use. <a
href="http://clojure-log.n01se.net/date/2012-05-01.html#19:34">Others</a> <a
href="http://clojure-log.n01se.net/date/2014-01-10.html#11:43d">have</a> <a
href="http://clojure-log.n01se.net/date/2016-12-09.html#02:17">mentioned</a> <a
href="https://clojurians-log.clojureverse.org/clojure/2016-04-09/1460232281.004707#inst-2016-04-09T23:04:41.004707Z">it</a>,
and Eric Normand wrote up a <a
href="https://purelyfunctional.tv/issues/purelyfunctional-tv-newsletter-322-tip-avoid-flatten-when-possible/">nice
example</a> of how it can betray you.</p> </p>

<p>Now if we've ruled out <code>flatten</code> for most common use cases, what
shall we use instead?</p>

<h2>Enumerating alternatives</h2>

<p>The Twitter poll choices were chosen <i>ad hoc</i>, so if we want to find the
best alternative, perhaps a more rigorous approach to finding alternatives is
warranted. There are a couple projects to help find all Clojure functions that
behave in a particular way: Michiel Borkent's somewhat confusingly named <a
href="https://github.com/borkdude/re-find">re-find</a> which leverages the
declared specs of functions (via <code>core.spec</code>) to find matches, and
Anthony Grimes's <a href="https://github.com/Raynes/findfn">findfn</a> which
tries calling all the functions and macros in namespace to see which produces
the desired results. Neither quite meets our requirements here because besides
finding single-function solutions like <code>flatten</code>, we also want
higher-order solutions like <code>apply concat</code>.</p>

<p>So I wrote a function to specifically look for expressions of the form
<code>(f1 f2 xs)</code> for any <i>f1</i> and <i>f2</i> that return the same
value as <code>(mapcat seq xs)</code>.</p>

<pre>
(defn find-phrases []
  (let [xs [[1 2 3] [4 5 6] [7 8 9]]
        goal (mapcat seq xs)
        vars (vals (ns-publics 'clojure.core))]

    (doall
     (for [v0 vars
           v1 vars
           :when (try
                    (= goal (@v0 @v1 xs))
                    (catch Throwable t false))]
       (list v0 v1 'xs)))))
</pre>

<p>I don't recommend you run this since it freezes, crashes, and breaks in
various ways. It turns out some combinations of core functions are not
well-behaved. But it's close: <code>vars</code> is a sequence of all public vars
in <code>clojure.core</code>, the <code>for</code> builds all pairs, and the
<code>:when</code> clause tries the pair and compares against our
<code>goal</code>.</p>

<figure style="float: right; width: 240px;">
<img alt="A very lazy cat, curled up, asleep, with a treasure map on its side"
  src="mapcat-identity.svg" onerror="this.src='mapcat-identity.jpg'"
  style="width: 240px; height: 156px;">
<figcaption>
  <b><code>mapcat identity</code> – </b>A close cousin to <code>mapcat
  seq</code>, but lazier.
</figcaption>
</figure>

<p>All that's left is to make it not fall apart, so I added a try/catch around
the scary test invocation. This wasn't enough, so I also manually excluded
several functions and a couple of combinations that caused problems and won't
meet the goal. <a href="">This version TODO FIXME</a> runs to completion in
about 11 seconds and finds 44 equivalent function combinations for the tested
input. Most of these use <code>mapcat</code>, since it turns out there are lots
of functions that act like <code>identity</code> in limited circumstances, for
example <code>mapcat sort</code>. But there are a few others, that look
interesting: <code>reduce into</code>, <code>sequence cat</code>, and
<code>eduction cat</code>.</p>

<h2>The eagerness of <code>reduce into</code></h2>

<figure style="float: right; width: 71px">
<img alt="A much smaller cat, looking somewhat startled."
  src="reduce-into.svg" onerror="this.src='reduce-into.jpg'"
  style="width: 71px; height: 68px">
<figcaption>
  <b><code>reduce into</code> – </b> This cat has been reduced.
</figcaption>
</figure>

<p>Most of the options mentioned above produce lazy sequences and are more or
less lazy themselves, but not <code>reduce into</code>. When <code>reduce</code>
is called without an <i>init</i> value it uses the first collection element
instead, and since <code>into</code> eagerly pours its second argument into its
first, the return value of <code>reduce into</code> is both fully eager and very
dependant on the type of the first collection element.</p>

<p>The examples in the table below demonstrate that while providing a initial
vector will result in value similar to other alternatives (though as a vector
instead of a sequence), with an initial list the remaining elements will be
reversed, and with an initial set the resulting collection is a set instead of a
sequence with a few elements in indeterminite order.</p>

<table class="examples">
  <tr>
    <th><i>input</i></th>
    <th><code>reduce into</code></th>
    <th><code>apply concat</code></th>
  </tr>
  <tr>
    <td><code>[ <b>[</b>1 2 3<b>]</b> [4 5 6]]</code></td>
    <td><code><b>[</b>1 2 3 4 5 6<b>]</b></code></td>
    <td><code><b>(</b>1 2 3 4 5 6<b>)</b></code></td>
  </tr>
  <tr>
    <td><code>[<b>'(</b>1 2 3<b>)</b> [4 5 6]]</code></td>
    <td><code>(<b>6 5 4</b> 1 2 3)</code></td>
    <td><code>(1 2 3 <b>4 5 6</b>)</code></td>
  </tr>
  <tr>
    <td><code>[<b>#{</b>1 2 3<b>}</b> [4 5 6]]</code></td>
    <td><code><b>#{</b>1 4 6 3 2 5<b>}</b></code></td>
    <td><code>(<b>1 3 2</b> 4 5 6)</code></td>
  </tr>
</table>

<p>So that's <code>reduce into</code>. The other interesting combinations found both use <code>cat</code>.

<h2>The <code>eduction</code> and <code>sequence</code> of <code>cat</code></h2>

<figure style="float: right; width: 259px">
<img alt="A sequence of three eager cats"
  src="sequence-cat.svg" onerror="this.src='sequence-cat.jpg'"
  style="width: 259px; height: 159px">
<figcaption>
  <b><code>sequence cat</code> – </b> Looks like a sequence of cats, but is actually a concatonation of sequences.
</figcaption>
</figure>

<p>I wasn't familiar with the function <code>cat</code> until
<code>find-phrases</code> found it.  Its docstring says it is a <em>transducer
which concatenates the contents of each input, which must be a collection, into
the reduction.</em>. The concatenation sounds exactly like what we need, so then
it's just a matter of finding something to collect the transducer into a
sequence. I would normally just <code>(into [] cat xs)</code>, but apparently if
I was more familiar with the transducer-related functions, I would have known
about <code>eduction</code> and <code>sequence</code>. Judging by their
docstrings, a key difference between them is that <code>sequence</code> can take
multiple collections and up to one transducer whereas <code>eduction</code> can
take multiple transducers and one collection. But since we only have one of
each, either <code>(eduction cat xs)</code> or <code>(sequence cat xs)</code>
will work.</p>

<p>Several of the <code>apply concat</code> alternatives we've found are so
far indistinguishable from each other. Although <code>flatten</code> and
<code>reduce into</code> behave differently, the rest return apparently
identical lazy sequences, so how shall we decide which to use? One obvious
metric would be speed, but microbenchmarks are difficult and of questionable
value. So why don't we look at something a bit more concrete: laziness.</p>

<h2>Tools for exploring laziness</h2>

<figure style="float: right; width: 157px">
<img alt="A happy cat with sleepy eyes."
  src="apply-concat.svg" onerror="this.src='apply-concat.jpg'"
  style="width: 157px; height: 152px; float: right; background: #fff">
<figcaption>
  <b><code>apply concat</code> – </b> Winner of the Twitter poll. Somewhat lazy.
</figcaption>
</figure>

<p>The laziness of a sequence is usually a bit tricky to observe. The easiest
approach is through side effects triggered as the sequence is realized, for
example <code>(map prn [1 2 3])</code> which returns a sequence of
<code>nil</code>s but prints each number as it is forced. This is sometimes
sufficient, but the input suquences we're dealing with here are nested, which
would print confusingly intermingled elements, so let's build a couple of tools
to make laziness easier to see.</p>

<p>Clojure's built-in printer (the <i>P</i> in <i>REPL</i>) forces lazy seqs.
But since the REPL printer, as well as <code>prn</code> and <code>pr-str</code>,
delegate to the <code>print-method</code> multimethod, we can replace the
implementation for <code>ISeq</code> with one that doesn't force lazy seqs. This
is the first tool we'll need.</p>

<pre>
(def ^:dynamic *hold-the-lazy* false)

(defn write-lazy-seq [space? coll w]
  (if (and *hold-the-lazy*
           (instance? clojure.lang.IPending coll)
           (not (realized? coll)))
    (.write w (str (when space? " ") "..."))
    (when (seq coll)
      (when space?
        (.write w " "))
      (.write w (pr-str (first coll)))
      (write-lazy-seq true (rest coll) w))))

(defmethod print-method clojure.lang.ISeq [coll w]
  (.write w "(")
  (write-lazy-seq false coll w)
  (.write w ")"))
</pre>

<p>By default, lazy seqs will print the same as usual:</p>

<pre>
(let [xs (map inc (range 10))]
  (prn xs))
</pre>
<pre class="prn">(1 2 3 4 5 6 7 8 9 10)</pre>

<p>But by binding <code>*hold-the-lazy*</code> while printing, we can now see
where there are unrealized values:</p>

<pre>
(let [xs (map inc (range 50))]
  (binding [*hold-the-lazy* true]
    (prn xs)))
</pre>
<pre class="prn">(...)</pre>

<p>Or we can rebind the root value to change the default behavior:</p>

<pre>
(alter-var-root #'chouser.mapcatseq/*hold-the-lazy* (constantly true))
(map inc (range 50))
</pre>
<pre class="prn">(...)</pre>

<p>Calling <code>first</code> on the sequence forces the <code>map</code>
function consume some of the <i>range</i> in order to compute the first
<i>inc</i>. But how much computation does it actually do?</p>

<pre>
(let [xs (map inc (range 50))]
  (first xs)
  (binding [*hold-the-lazy* true]
    (prn xs)))
</pre>
<pre class="prn">
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30 31 32 ...)</pre>
</pre>

<p>Note that the <i>realization</i> of the values is a side-effect of calling
<code>(first xs)</code>, which is why we can discard that expression's return
value and instead print the origal <code>xs</code> sequence afterward.</p>

<p>Another detail to notice is that when <code>map</code> is asked to compute
the first value, it actually computes the first 32 values, a feature called
<i>chunking</i> that is meant to amortize the overhead of creating the new lazy
sequence. But if we want to understand precisely how lazy our various
expressions are, we're going to need something that doesn't chunk</p>

-->

<p>With this tool in our belt, we're ready to see what just how lazy our various
flatteners are.</p>

<h2>Multidimentional laziness</h2>

<br clear="all">
<hr>
<hr>
<hr>

<h2><code>(apply concat xs)</code>
<img alt="A happy cat with sleepy eyes."
  src="apply-concat.svg" onerror="this.src='apply-concat.jpg'"
  style="width: 157px; height: 152px; float: right; background: #fff">
<img alt="Laziness: 4/5" src="lazy4.svg" class="laziness-svg">
</h2>

<p>Here's an example of what <code>apply concat</code> can do:</p>

<pre>
(apply concat [[1 2 3] [4 5 6] [7 8 9]])
;=&gt; (1 2 3 4 5 6 7 8 9)
</pre>

<p>This is a way to remove one layer of nesting in a sequence of sequences. I
think it's comfortable for people because <code>concat</code> is already very
close to what we want, and <code>apply</code> is straightforward for getting the
rest of the way there.</p>

<p>It's also one of the lazier options among the several we will examine, a
detail you might guess by the look in its eyes. When called, it will realize the
first several sequences of the input, but will pull none of the elements from
any them until required. </p>

<p>So if <code>apply concat</code> gets the job done, is easy to understand, and
has such a cute illustration, why even consider anything else?</p>


<h2><code>(mapcat seq xs)</code>
<img alt="Cat on her back with a treasure map on her belly."
  src="mapcat-seq.svg" onerror="this.src='mapcat-seq.jpg'"
  style="width: 286px; height: 135px; float: right">
</h2>
<img alt="Laziness: 3/5" src="lazy3.svg" class="laziness-svg" style="clear: right">

<p>This one gets the job done too. It also realizes the first several
sequences, just like <code>apply concat</code>. In fact it realizes exactly the
same number of sequences (four, in Clojure 1.10). This surprised me, so I peeked
at the definition of <code>mapcat</code> and found it includes this expression:

<pre>(apply concat (apply map f colls))</pre>

<p>Ah ha! The top-level laziness is the same because <code>mapcat</code>
actually <i>calls</i> <code>apply concat</code>. However, the use
<code>seq</code> means that the first element of each sequence is realized as
soon as the <code>mapcat seq</code> is, making it a little more eager than
<code>apply concat</code>.</p>

<p>So what did Christophe find so <em>pleasant</em> about this alternative
those many years ago? I haven't asked him yet, but the reason it's been my
favorite is that it is the <em>shortest</em> of the good solutions
(we'll talk about why <code>flatten</code> doesn't qualify in a moment).  It beats
<code>reduce into</code> by a character and <code>apply concat</code> by two!
This is critical when golfing your <a href="http://www.4clojure.com/">4clojure</a>
solutions.</p>

<p>Ah, but <code>flatten</code> is indeed even shorter! So why my bold claim
that it isn't a "good solution"?</p>

<p>I don't want malign <code>flatten</code> too much: it's powerful, lazy,
and an excellent example usage of <code>tree-seq</code>. Although its <a
  href="https://groups.google.com/forum/#!msg/clojure/sqok3RqGEC8/m63Kv_qYUDgJ">implementation</a>
is succinct, it's not very obvious, so it can be an valuable tool when you need
it.</p>

<img alt="Laziness: 4/5" src="lazy4.svg" class="laziness-svg" style="clear:right">

<p>But you almost never need it.</p>

<p>Only rarely do I have
multiple levels of nested sequences that I want to flatten, for which
<code>flatten</code>'s idea of what things are sequences (lists but not sets,
vectors but not arrays) matches my needs. And if <code>flatten</code> is used
when only one level of flattening is desired, surprising and an unwanted
consequences can result. I'm not alone in warning about its use.
<a href="http://clojure-log.n01se.net/date/2012-05-01.html#19:34">Others</a> <a href="http://clojure-log.n01se.net/date/2014-01-10.html#11:43d">have</a> <a href="http://clojure-log.n01se.net/date/2016-12-09.html#02:17">mentioned</a> <a href="https://clojurians-log.clojureverse.org/clojure/2016-04-09/1460232281.004707#inst-2016-04-09T23:04:41.004707Z">it</a>, and Eric Normand even wrote a <a href="https://purelyfunctional.tv/issues/purelyfunctional-tv-newsletter-322-tip-avoid-flatten-when-possible/">nice example</a> of how it can betray you.</p>
</p>

<p>So imagine my dismay when <code>flatten</code> briefly led my Twitter poll,
and ended up a close second behind <code>apply concat</code>!</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Just because they do different things doesn&#39;t mean you can&#39;t have a favorite.</p>&mdash; Chouser (@chrishouser) <a href="https://twitter.com/chrishouser/status/1118913793512411136?ref_src=twsrc%5Etfw">April 18, 2019</a>
<img src="shot-20190517-090932.png" style="width: 175px; height: 172px">
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>In fact it was that poll result that inspired this post. Please don't use <code>flatten</code> unthinkingly, especially when there are so many other attractive alternatives!</p>

<p>For example, why not use <code>reduce</code>?

<h2><code>(reduce into xs)</code>
<img alt="Laziness: 1/5" src="lazy1.svg" class="laziness-svg">
<img alt="A much smaller cat, looking somewhat startled."
  src="reduce-into.svg" onerror="this.src='reduce-into.jpg'"
  style="width: 71px; height: 68px; float: right; margin: 0 2em">
</h2>

<p>Perhaps laziness doesn't fit your needs, and you'd rather use something as
eager as possible. Well then, <code>reduce into</code> is your bag. Since
<code>into</code> uses an existing collection instance, this won't return a
sequence like the others we've looked at so far. While it returns what you
probably expect for vectors of vectors, if the first collection you give it is
a set or list, the result might not be in the order you want.

<pre>
(reduce into [[1 2 3] [4 5 6] [7 8 9]])  ;=&gt; [1 2 3 4 5 6 7 8 9]
(reduce into [#{1 2 3} [4 5 6] [7 8 9]]) ;=&gt; #{7 1 4 6 3 2 9 5 8}
(reduce into '[(1 2 3) (4 5 6) (7 8 9)]) ;=&gt; (9 8 7 6 5 4 1 2 3)
</pre>

<p>On the other hand it may be exactly what you want for combining several maps into one.</p>

<pre>
(reduce into '[{a 1, b 2} {c 3, d 4} {e 5 f 6}])
;=&gt; {a 1, b 2, c 3, d 4, e 5, f 6}
</pre>

<p>But wait, there's more!  Next up is <code>mapcat seq</code>'s cousin <code>mapcat identity</code>.</p>

<h2><code>(mapcat identity xs)</code>
<img alt="A very lazy cat, curled up, asleep, with a treasure map on its side"
  src="mapcat-identity.svg" onerror="this.src='mapcat-identity.jpg'"
  style="width: 240px; height: 156px; float: right;">
<img alt="Laziness: 4/5" src="lazy4.svg" class="laziness-svg" style="clear: right; float: left">
</h2>

<p>This gregarious creature has the laziness of <code>apply
concat</code>, the same first name as <code>mapcat seq</code>, and the same last
name as that Bourne movie (not to be confused with the Bourne Shell.</p>

<p>In fact its behavior is so similar to <code>apply concat</code> that the only
reason to include it here is because its just so cute.</p>

<p>Ok, just one more:</p>

<h2><code>(sequence cat xs)</code>
<img alt="A sequence of three eager cats"
  src="sequence-cat.svg" onerror="this.src='sequence-cat.jpg'"
  style="width: 259px; height: 159px; float: right">
<img alt="Laziness: 2/5" src="lazy2.svg" class="laziness-svg">
</h2>

<p>This one's interesting because it combines an old function
(<code>sequence</code> introduced Feb 2009) with one that came a few years later
(<code>cat</code>, May 2012).</p>

<p>It also has an unusual laziness profile, fully realizing the first sequence
the moment its called, and then realizing all the rest if any actual elements
are requested (such as by calling <code>first</code> on the result).</p>

<h1>Finally...</h1>

<p>I wrote <a href="https://github.com/chouser/mapcatseq">some code</a> to help
explore this space. It's a bit of a mess but includes the generative tests I
used to discover that <code>eduction cat</code> is yet another option. It also
has a mechanism that prints only the parts of lazy sequences that have already
been realized, instead of realizing the whole sequence like print usually does.
Finally, it also defines a <code>lazier-mapcat</code> which can be used to build
the laziest solution of all.</p>

<p>I didn't compare the performance of these alternatives, because I doubt such
microbenchmarks would have any value at all. So as long as you don't pick
<code>flatten</code> when you don't need it, I think you're probably better off
choosing which to use based on the cuteness of its illustration.</p>

<img alt="Mapcat seq, a cat on her back with a treasure map on her belly."
  src="mapcat-seq.svg" onerror="this.src='mapcat-seq.jpg'"
  style="width: 286px; height: 135px; float: right">

<p>The fact that <code>apply concat</code> is more fundamental than <code>mapcat
seq</code> shook me a bit, and raised my estimation of it, so I commend all of
you who voted for it in the first place. I will probably continue use
<code>mapcat seq</code> when its eagerness doesn't matter, because don't you
just want to rub its belly!?</p>

<div class="byline">by Chouser, <time datetime="2019-05-21">May 21, 2019</time></div>
<div class="byline">illustrations by Anna Houser</div>

<p>P.S. If you have a sequence of maps, I just realized <code>(apply merge
x)</code> is a pleasant alternative to <code>(reduce into x)</code>.</p>

</main>

</body>
</html>
